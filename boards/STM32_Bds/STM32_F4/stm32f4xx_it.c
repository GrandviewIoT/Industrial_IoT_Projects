/**
  ******************************************************************************
  * @file    TIM/TIM_PWMInput/Src/stm32f4xx_it.c
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    26-December-2014
  * @brief   Main Interrupt Service Routines.
  *          This file provides template for all exceptions handler and
  *          peripherals interrupt service routine.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

#include "user_api.h"                   // pull in defs for User API calls
#include "boarddef.h"                   // MCU and Board specific parms/pins/etc

    volatile  uint32_t  _g_EXTI_rupt_pins;

void  BNRG_SPI_EXTI_IRQHandler (void);  // WVD Adds for BLUENRG BLE IRQ Hdlr
void  BlueNRG_EXTI_IRQ_Handler (void);
void  EXTI0_IRQHandler (void);
extern void Timer2_ISR(void);           // WVD Adds for W5200
void  TIM2_IRQHandler (void);           // function prototypes  WVD
void  TIM3_IRQHandler(void);
void  USART1_IRQHandler(void);
void  USART2_IRQHandler(void);
void  EXTI9_5_IRQHandler (void);        // L474 / Spirit1 IRQ
void  EXTI15_10_IRQHandler (void);      // Push Button IRQ Handler
void  board_vtimer_check_expiration (uint32_t gsystick_millisecs);  // VTIMER


/** @addtogroup STM32F4xx_HAL_Examples
  * @{
  */

/** @addtogroup TIM_PWMInput
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

extern  TIM_HandleTypeDef   TimHandle;

        volatile uint8_t    button_event = 0;

        unsigned long       exti_IT_5_9_rupts_seen = 0;
        unsigned long       exti_IT_10_15_rupts_seen = 0;


/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/******************************************************************************/
/*            Cortex-M4 Processor Exceptions Handlers                         */
/******************************************************************************/

/**
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}

/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
      // Go to infinite loop when Hard Fault exception occurs.
      // Is normally generated by a Bus Fault, due to a bad memory pointer
  while (1)
    {
    }
}

/**
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
}

/**
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}

/**
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
}

/**
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
}


/*******************************************************************************
*                           SysTick_Handler
*
* @brief  This function handles SysTick Handler.
* @param  None
* @retval None
******************************************************************************/
void  SysTick_Handler (void)
{
    HAL_IncTick();
//  TimingDelay_Decrement();               // call user level handler in main.c

#if defined(USES_VTIMER)
extern  char  _g_vtimers_active;

    if (_g_vtimers_active > 0)
       board_vtimer_check_expiration (HAL_GetTick());
#endif
}


/******************************************************************************/
/*                 STM32F4xx Peripherals Interrupt Handlers                   */
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32f4xx.s).                                               */
/******************************************************************************/


#if defined(USES_BLUENRG_BLE)
/********************************************************************************
* @brief  BNRG_SPI_EXTI_IRQHandler This function handles External line
*         interrupt request for BlueNRG.
*
* @param  None
* @retval None
*
* This invokes the generic HAL EXTI ISR handler, which in turn then calls
* our EXTI_Handler.
*******************************************************************************/
//void  BNRG_SPI_EXTI_IRQHandler (void)        // aka EXTI0_IRQHandler   WORKS
//void  BlueNRG_EXTI_IRQ_Handler (void)                  FAILS TO LINK PROPERLY
void  EXTI0_IRQHandler (void)
{
//  HAL_GPIO_EXTI_IRQHandler (BNRG_SPI_EXTI_PIN);
    HAL_GPIO_EXTI_IRQHandler (BlueNRG_IRQ_PIN);
}
#endif


/******************************************************************************
* @brief  This function handles External lines 5 to 9 interrupt request.
*
*         Spirit IRQ line is tied to PC7, so interrupt occurs on EXTI 7
*
* @param  None
* @retval None
******************************************************************************/
#if defined(USES_WIFI_101)
    // is in nm_bus_wrapper_stm32.c for now
#else
void  EXTI9_5_IRQHandler (void)
{
    _g_EXTI_rupt_pins = EXTI->PR;   // PR contains which pin(s) raised interrupt

exti_IT_5_9_rupts_seen++;

#if defined(SPIRIT1_ST_SHIELD)
void P2PInterruptHandler(void);

      //----------------------------------------------------
      //         Spirit1 support for Button Press
      //----------------------------------------------------
      /* EXTI line 7 interrupt detected - this is GPIO_3 IRQ from Spirit Board */
  if (__HAL_GPIO_EXTI_GET_IT(SUB_GHZ_GPIO_3_EXTI_PIN) != RESET)
     {
       __HAL_GPIO_EXTI_CLEAR_IT (SUB_GHZ_GPIO_3_EXTI_PIN);

       P2PInterruptHandler();
     }
#endif                           // #if defined(SPIRIT1_ST_SHIELD)

       // ensure pin(s) causing rupt are cleared, or will get tight interrupt loop
//  __HAL_GPIO_EXTI_CLEAR_IT (_g_EXTI_rupt_pins);   // hammer all pending rupts ! Either doe a subset of lines 4-9, or leave alone
}
#endif


/********************************************************************************
* @brief  EXTI4_15_IRQHandler This function handles External lines 4 to 15 interrupt request.
*
* @param  None
* @retval None
*******************************************************************************/
//void  PUSH_BUTTON_EXTI_IRQHandler (void)
//{
//    HAL_GPIO_EXTI_IRQHandler (KEY_BUTTON_PIN);
//
//    button_event = 1;               // Denote the user button was pushed
//}


/*******************************************************************************
*                           EXTI15_10_IRQHandler
*
* @brief  This function handles EXTI15_10_IRQHandler Handler.  -> BUTTON press
*         This function handles External lines 10 to 15 interrupt request.
*
*         Nucleo Button is always tied to PC13, so interrupt occurs on EXTI 13
*
* @param  None
* @retval None
*******************************************************************************/
void  EXTI15_10_IRQHandler (void)
{
    _g_EXTI_rupt_pins = EXTI->PR;   // PR contains which pin(s) raised interrupt

exti_IT_10_15_rupts_seen++;

#if defined(SPIRIT1_ST_SHIELD)
void Set_KeyStatus(int flag);

      //----------------------------------------------------
      //         Spirit1 support for Button Press
      //----------------------------------------------------
      /* EXTI line 13 interrupt detected */
 #ifndef  LPM_ENABLE

//if (EXTI->PR & USER_BUTTON_PIN)
  if (__HAL_GPIO_EXTI_GET_IT(BOARD_USER_BUTTON_PIN) != RESET)
     {
       __HAL_GPIO_EXTI_CLEAR_IT(BOARD_USER_BUTTON_PIN);

       Set_KeyStatus (SET);
     }


 #else      /****  Low Power mode enabled  ****/

  #if defined(RF_STANDBY)   /* if spirit1 is in standby */

  if (EXTI->PR & BOARD_USER_BUTTON_PIN)
     {
      HAL_GPIO_EXTI_Callback (BOARD_USER_BUTTON_PIN);

         /* EXTI line 13 interrupt detected */
      if (HAL_GPIO_ReadPin(KEY_BUTTON_GPIO_PORT, BOARD_USER_BUTTON_PIN) == 0x01) //0x00
         {
           HAL_GPIO_EXTI_Callback (BOARD_USER_BUTTON_PIN);

           PushButtonStatusWakeup = SET;
           PushButtonStatusData   = RESET;
           wakeupCounter          = LPM_WAKEUP_TIME;
           dataSendCounter        = DATA_SEND_TIME;
           dataSendCounter++;
         }
      __HAL_GPIO_EXTI_CLEAR_IT (BOARD_USER_BUTTON_PIN);
    }

  #else  /* if spirit1 is not in LOW POWER standby or sleep mode but MCU is in LPM */

  if (__HAL_GPIO_EXTI_GET_IT(BOARD_USER_BUTTON_PIN) != RESET)
     {
       __HAL_GPIO_EXTI_CLEAR_IT (BOARD_USER_BUTTON_PIN);

       HAL_GPIO_EXTI_Callback (BOARD_USER_BUTTON_PIN);

       Set_KeyStatus(SET);
     }
  #endif
 #endif
#endif                            // #if SPIRIT1_ST_SHIELD

#if defined(MAYBE_IN_FUTURE)
    if (EXTI_GetITStatus(BOARD_USER_BUTTON_PIN) == SET)
       {
         if (BlinkSpeed == 1)
            {
              BlinkSpeed = 0;
            }
           else
            {
              BlinkSpeed ++;

            }
               /* Clear the EXTI line pending bit */
         EXTI_ClearITPendingBit (BOARD_USER_BUTTON_PIN);
       }
#endif


#if defined(USES_L6474)
        // this is used by EasySpin_L6474 IRQ rupt pin    08/06/15 - is now being called 09/07/15
        // and by SubGHz Spirit1 IRQ pin
    HAL_GPIO_EXTI_IRQHandler (GPIO_PIN_10);     // aka PA10 used by L6474 IRQ
#endif


#if FIX_LATER
         EXTI_ClearITPendingBit (BOARD_USER_BUTTON_EXTI_LINE);
#endif

       // ensure pin(s) causing rupt are cleared, or will get tight interrupt loop
//  __HAL_GPIO_EXTI_CLEAR_IT (_g_EXTI_rupt_pins);   // hammer all pending rupts ! Either doe a subset of lines 10-15, or leave alone

}


/********************************************************************************
* @brief  This function handles TIM interrupt request.
* @param  None
* @retval None
*******************************************************************************/
void TIMx_IRQHandler(void)
{
    HAL_TIM_IRQHandler (&TimHandle);
}


#if  FUTURE
/*******************************************************************************
* Function Name  : USART1_IRQHandler
* Description    : This function handles USART1 global interrupt request.
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void USART1_IRQHandler(void)
{

}

/*******************************************************************************
* Function Name  : USART2_IRQHandler
* Description    : This function handles USART2 global interrupt request.
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void USART2_IRQHandler(void)
{

}
#endif                     //FUTURE



#if defined(USES_I2C)            // defined in F4_device_support.h file
//******************************************************************************
//                         I2C     ISR / IRQ     Handlers
//******************************************************************************
void  I2C1_EV_IRQHandler (void);
void  I2C1_ER_IRQHandler (void);
void  I2C2_EV_IRQHandler (void);
void  I2C2_ER_IRQHandler (void);
void  I2C3_EV_IRQHandler (void);
void  I2C3_ER_IRQHandler (void);

volatile  uint32_t   num_I2C1_rupts = 0;
volatile  uint32_t   num_I2C1_error_rupts = 0;

extern  int   i2c_rupt_module_id;            // TEMP_HACK

//extern I2C_HandleTypeDef  I2CxHandle;

/*******************************************************************************
*                              I2C    ISRs
*
*   This function handles I2C event interrupt requests.
*
*      @param  None
*      @retval None
*      @Note   This function is redefined in "main.h" and related to I2C data transmission
******************************************************************************/
void  I2C1_EV_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
num_I2C1_rupts++;
//  HAL_I2C_EV_IRQHandler (&I2CxHandle);    // call associated STM32 handlers in HAL_i2C routines
//  HAL_I2C_ER_IRQHandler (&I2CxHandle);
    i2c_rupt_module_id = 1;
    board_i2c_IRQ_Handler (1);     // Invoke common I2C ISR handler
}

void  I2C1_ER_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
num_I2C1_error_rupts++;
//  HAL_I2C_ER_IRQHandler (&I2CxHandle);
    i2c_rupt_module_id = 1;
    board_i2c_ERRIRQ_Handler (1);  // Invoke common I2C ISR handler
}


void  I2C2_EV_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
    i2c_rupt_module_id = 2;
    board_i2c_IRQ_Handler (2);     // Invoke common I2C ISR handler
}


void  I2C2_ER_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
    i2c_rupt_module_id = 2;
    board_i2c_ERRIRQ_Handler (2);  // Invoke common I2C ISR handler
}


void  I2C3_EV_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
    i2c_rupt_module_id = 2;
    board_i2c_IRQ_Handler (3);     // Invoke common I2C ISR handler
}


void  I2C3_ER_IRQHandler (void)  // brute force - link editor was not picking up 05/11/15
{
    i2c_rupt_module_id = 2;
    board_i2c_ERRIRQ_Handler (3);  // Invoke common I2C ISR handler
}

#endif



#if defined(USES_SPI)            // defined in F4_device_support.h file
//******************************************************************************
//                         SPI     ISR / IRQ     Handlers
//******************************************************************************
void  SPI1_IRQHandler (void);
void  SPI2_IRQHandler (void);
void  SPI3_IRQHandler (void);
void  SPI4_IRQHandler (void);

void  SPI1_IRQHandler (void)
{
    board_spi_IRQ_Handler (1);     // Invoke common SPI ISR handler
}

void  SPI2_IRQHandler (void)
{
    board_spi_IRQ_Handler (2);     // Invoke common SPI ISR handler
}

void  SPI3_IRQHandler (void)
{
    board_spi_IRQ_Handler (3);     // Invoke common SPI ISR handler
}

void  SPI4_IRQHandler (void)
{
    board_spi_IRQ_Handler (4);     // Invoke common SPI ISR handler
}

#endif



/*******************************************************************************
  * @brief  This function handles DMA Rx interrupt request.
  * @param  None
  * @retval None
******************************************************************************/
extern  SPI_HandleTypeDef  SpiHandle;

#if FIX_LATER
void  SPIx_DMA_RX_IRQHandler (void)
{
    HAL_DMA_IRQHandler (SpiHandle.hdmarx);
}
#endif


/*******************************************************************************
  * @brief  This function handles DMA Tx interrupt request.
  * @param  None
  * @retval None
******************************************************************************/
#if FIX_LATER
void  SPIx_DMA_TX_IRQHandler (void)
{
    HAL_DMA_IRQHandler (SpiHandle.hdmatx);
}
#endif

/*******************************************************************************
  * @brief  This function handles PPP interrupt request.
  * @param  None
  * @retval None
*******************************************************************************/
/*void PPP_IRQHandler(void)
{
}*/

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
